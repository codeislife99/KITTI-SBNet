var FsTransport, Ignore, Manifest, Transport, async, createLogger, defaults, getStream, mkdirp, nsync, path, version, _ref, _ref1;

async = require('async');

Ignore = require('ignore').Ignore;

path = require('path');

version = require('./version');

Manifest = require('./manifest').Manifest;

_ref = require('./utils'), mkdirp = _ref.mkdirp, getStream = _ref.getStream;

_ref1 = require('./transport'), Transport = _ref1.Transport, FsTransport = _ref1.FsTransport;

defaults = {
  manifest: 'manifest.json',
  forceRebuild: false,
  concurrency: 4,
  destructive: false,
  sourcePath: './',
  destinationPath: './',
  ignore: ['.git', '.DS_Store'],
  pretend: false,
  logger: null
};

createLogger = function() {
  var bunyan, logger;
  bunyan = require('bunyan');
  logger = bunyan.createLogger({
    name: 'nsync',
    streams: [
      {
        stream: process.stderr,
        level: 'debug'
      }
    ]
  });
  return logger;
};

nsync = function(source, destination, options, callback) {

  /* Synchronize *source* transport to *destination* transport using *options*.
      Calls *callback* when done or if an error occurs.
   */
  var cleanup, dircache, done, ignore, key, loadManifests, logger, manifestPath, manifests, pretend, saveManifest, setupTransports, start, stats, syncFiles, useManifest, validateTransports, _ref2;
  if (arguments.length === 3) {
    callback = options;
    options = {};
  }
  for (key in defaults) {
    if (options[key] == null) {
      options[key] = defaults[key];
    }
  }
  pretend = options.pretend;
  manifests = null;
  dircache = {};
  logger = (_ref2 = options.logger) != null ? _ref2 : createLogger();
  ignore = new Ignore({
    twoGlobstars: true,
    ignore: options.ignore
  });
  start = process.hrtime();
  stats = {
    added: 0,
    modified: 0,
    removed: 0,
    bytesTransfered: 0
  };
  done = function(error) {
    stats.time = process.hrtime(start);
    if (error != null) {
      logger.fatal(error);
    } else {
      logger.info({
        stats: stats
      }, 'Done!');
    }
    return callback(error, stats);
  };
  logger.debug({
    options: options
  }, 'Version %s', version);
  useManifest = !!options.manifest;
  if (useManifest) {
    manifestPath = path.join(options.destinationPath, options.manifest);
    ignore.addPattern(options.manifest);
  }
  source.logger = logger.child({
    transport: Transport.getName(source)
  });
  destination.logger = logger.child({
    transport: Transport.getName(destination)
  });
  validateTransports = function(callback) {
    var error;
    logger.debug('Validating transports');
    try {
      Transport.validate(source);
      Transport.validate(destination);
    } catch (_error) {
      error = _error;
    }
    return callback(error);
  };
  setupTransports = function(callback) {
    logger.debug('Setup transports');
    return async.parallel([
      function(callback) {
        return source.setup(callback);
      }, function(callback) {
        return destination.setup(callback);
      }
    ], callback);
  };
  loadManifests = function(callback) {
    logger.debug('Loading manifests');
    return async.parallel({
      source: function(callback) {
        logger.debug('Building source manifest from %s', options.sourcePath);
        return Manifest.fromDirectory(options.sourcePath, source, options.concurrency, callback);
      },
      destination: function(callback) {
        return async.waterfall([
          function(callback) {
            if (useManifest && !options.forceRebuild) {
              logger.debug('Loading manifest from destination');
              return Manifest.fromFile(manifestPath, destination, function(error, manifest) {
                if (error != null) {
                  logger.debug("No manifest found, rebuilding");
                }
                return callback(null, manifest);
              });
            } else {
              return callback(null, null);
            }
          }, function(manifest, callback) {
            if (manifest == null) {
              logger.debug("Building manifest from destination");
              return Manifest.fromDirectory(options.destinationPath, destination, options.concurrency, callback);
            } else {
              return callback(null, manifest);
            }
          }
        ], callback);
      }
    }, function(error, result) {
      if (error == null) {
        manifests = result;
      }
      return callback(error);
    });
  };
  syncFiles = function(callback) {
    var diffs, flow, handleDiff, makeDirectores, preserveDeletions, removeEmpty, test;
    logger.debug('Building diff');
    diffs = Manifest.diff(manifests.destination, manifests.source);
    test = ignore.createFilter();
    logger.debug({
      patterns: ignore._patterns
    }, 'Filtering out ignored files');
    diffs = diffs.filter(function(diff) {
      if (!test(diff.file)) {
        logger.trace("Ignoring " + diff.file);
        return false;
      }
      return true;
    });
    logger.debug("Diff size: " + diffs.length);
    if (diffs.length === 0) {
      logger.info("Already syncrhonized, exiting...");
      return callback();
    }
    makeDirectores = function(callback) {
      var newDirectories;
      newDirectories = diffs.filter(function(diff) {
        return diff.type === 'new';
      }).map(function(diff) {
        return path.dirname(path.join(options.destinationPath, diff.file));
      }).filter(function(dir, idx, arr) {
        return arr.indexOf(dir) === idx;
      });
      return async.forEachSeries(newDirectories, function(dir, callback) {
        logger.debug("Creating directory: " + dir);
        if (!pretend) {
          return mkdirp(destination, dir, dircache, callback);
        } else {
          return callback();
        }
      }, callback);
    };
    removeEmpty = function(callback) {
      var toDelete;
      toDelete = diffs.filter(function(diff) {
        return diff.type === 'delete';
      }).map(function(diff) {
        return path.dirname(path.join(options.destinationPath, diff.file));
      }).filter(function(dir, idx, arr) {
        return arr.indexOf(dir) === idx;
      });
      return async.forEachSeries(toDelete, function(dir, callback) {
        return async.waterfall([
          function(callback) {
            return destination.listDirectory(dir, callback);
          }, function(items, callback) {
            if (items.length === 0) {
              logger.debug("Removing empty directory: " + dir);
              if (!pretend) {
                return destination.deleteDirectory(dir, callback);
              } else {
                return callback();
              }
            } else {
              return callback();
            }
          }
        ], callback);
      }, callback);
    };
    handleDiff = function(diff, callback) {
      var fromFile, toFile;
      toFile = path.join(options.destinationPath, diff.file);
      fromFile = path.join(options.sourcePath, diff.file);
      logger.debug("" + fromFile + " -> " + toFile);
      switch (diff.type) {
        case 'new':
        case 'change':
          logger.info({
            diff: diff
          }, '%s: %s', diff.type, diff.file);
          if (diff.type === 'new') {
            stats.added += 1;
          }
          if (diff.type === 'change') {
            stats.modified += 1;
          }
          stats.bytesTransfered += diff.size;
          if (!pretend) {
            return async.waterfall([
              function(callback) {
                return getStream(source, fromFile, callback);
              }, function(stream, callback) {
                return destination.putFile(toFile, diff.size, stream, callback);
              }
            ], callback);
          } else {
            return callback();
          }
          break;
        case 'delete':
          if (options.destructive) {
            stats.removed += 1;
            logger.info({
              diff: diff
            }, '%s: %s', diff.type, diff.file);
            if (!pretend) {
              return destination.deleteFile(toFile, callback);
            } else {
              return callback();
            }
          } else {
            return callback();
          }
          break;
        default:
          return callback(new Error("Unknown diff type: " + diff.type));
      }
    };
    preserveDeletions = function(callback) {
      var diff, _i, _len;
      for (_i = 0, _len = diffs.length; _i < _len; _i++) {
        diff = diffs[_i];
        if (diff.type === 'delete') {
          manifests.source.files[diff.file] = [diff.oldSize, diff.oldHash];
        }
      }
      return callback();
    };
    flow = [];
    flow.push(makeDirectores);
    flow.push(function(callback) {
      return async.forEachLimit(diffs, options.concurrency, handleDiff, callback);
    });
    if (options.destructive) {
      flow.push(removeEmpty);
    }
    if (!options.destructive) {
      flow.push(preserveDeletions);
    }
    async.series(flow, callback);
  };
  saveManifest = function(callback) {
    if (!useManifest) {
      return callback();
    }
    logger.debug("Writing manifest to destination (" + manifestPath + ")");
    if (!pretend) {
      return async.series([
        function(callback) {
          return mkdirp(destination, path.dirname(manifestPath), dircache, callback);
        }, function(callback) {
          return manifests.source.toFile(manifestPath, destination, callback);
        }
      ], callback);
    } else {
      return callback();
    }
  };
  cleanup = function(callback) {
    logger.debug('Cleanup transports');
    return async.parallel([
      function(callback) {
        return source.cleanup(callback);
      }, function(callback) {
        return destination.cleanup(callback);
      }
    ], callback);
  };
  async.series([validateTransports, setupTransports, loadManifests, syncFiles, saveManifest, cleanup], done);
};


/* Exports */

module.exports = nsync;

module.exports.defaults = defaults;

module.exports.version = version;

module.exports.Manifest = Manifest;

module.exports.Transport = Transport;

module.exports.FsTransport = FsTransport;

//# sourceMappingURL=index.map