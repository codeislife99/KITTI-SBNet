
/* nsync command line interface */
var CliStream, bunyan, camel2dash, chalk, createLogger, dash2camel, defaults, fs, isTransport, listModules, lpad, main, minimist, normalizeTransportName, nsync, optionsUsage, path, readJSONSync, resolveOptions, resolveTransport, rpad, transportUsage, usage, writeJSONSync, _ref;

chalk = require('chalk');

fs = require('fs');

listModules = require('./list');

minimist = require('minimist');

nsync = require('./../');

path = require('path');

CliStream = require('./logger').CliStream;

bunyan = require('bunyan');

_ref = require('./../utils'), readJSONSync = _ref.readJSONSync, writeJSONSync = _ref.writeJSONSync;

defaults = {
  destination: './',
  manifest: 'manifest.json',
  concurrency: 4,
  destructive: false,
  force: false,
  pretend: false,
  gitignore: true,
  ignore: []
};

usage = "usage: nsync " + (chalk.bold('<transport>')) + " [options] " + (chalk.bold('<input directory>'));

optionsUsage = "options:\n\n  -c, --config <filename>     config file to use (default: ./nsync.json)\n  -d, --destination <path>    path to write to on destination (default: ./)\n  -f, --force                 force rebuild of destination manifest\n  -m, --manifest <filename>   manifest filename to use (default: manifest.json)\n      --no-manifest           dont use a manifest\n  -C, --concurrency <num>     max number of concurrent operations (default: 4)\n  -i, --ignore                file or pattern to ignore (repeatable)\n      --no-gitignore          disable parsing of .gitignore files\n  -X, --destructive           delete files and directories on destination\n  -p, --pretend               don't actually do anything\n  -S, --save [filename]       save current options to config file\n  -q, --quiet                 only output critical errors\n  -V, --version               output version and exit\n      --debug                 show debug information\n      --json                  output json log stream\n  -h, --help                  show usage\n";

isTransport = function(name) {
  return /^nsync\-/.test(name);
};

normalizeTransportName = function(name) {
  return name.replace(/^nsync\-/, '');
};

camel2dash = function(string) {
  return string.replace(/([A-Z])/g, function(m) {
    return "-" + (m.toLowerCase());
  });
};

dash2camel = function(string) {
  return string.replace(/(\-[a-z])/g, function(m) {
    return m.toUpperCase().replace('-', '');
  });
};

resolveTransport = function(name) {
  var error, id;
  switch (name[0]) {
    case '.':
      id = require.resolve(path.join(process.cwd(), name));
      break;
    case '/':
      id = require.resolve(name);
      break;
    default:
      try {
        id = require.resolve("nsync-" + name);
      } catch (_error) {
        error = _error;
        if (error.code === 'MODULE_NOT_FOUND') {
          id = require.resolve(name);
        } else {
          throw error;
        }
      }
  }
  return id;
};

resolveOptions = function(argv, config, defaults) {
  var key, options, _ref1;
  options = {};
  for (key in defaults) {
    options[key] = (_ref1 = argv[key]) != null ? _ref1 : argv[camel2dash(key)];
    if (options[key] == null) {
      options[key] = config[key];
    }
    if (options[key] == null) {
      options[key] = defaults[key];
    }
  }
  return options;
};

lpad = function(str, length, padStr) {
  if (padStr == null) {
    padStr = ' ';
  }
  while (str.length < length) {
    str = padStr + str;
  }
  return str;
};

rpad = function(str, length, padStr) {
  if (padStr == null) {
    padStr = ' ';
  }
  while (str.length < length) {
    str = str + padStr;
  }
  return str;
};

transportUsage = function(transport) {
  var extra, key, opt, pad, rv, _ref1;
  rv = "transport options:\n\n";
  pad = Object.keys(transport.options).map(camel2dash).reduce(function(prev, current) {
    return Math.max(prev.length || prev, current.length);
  });
  _ref1 = transport.options;
  for (key in _ref1) {
    opt = _ref1[key];
    rv += rpad("  --" + (camel2dash(key)), pad + 6);
    rv += "  " + opt.description;
    if (opt.required || opt["default"]) {
      extra = [];
      if (opt.required) {
        extra.push('required');
      }
      if (opt["default"] != null) {
        extra.push("default: " + opt["default"]);
      }
      rv += " (" + (extra.join(', ')) + ")";
    }
    rv += '\n';
  }
  return rv;
};

createLogger = function(options, output) {
  var level, logger, stream, type;
  if (output == null) {
    output = process.stdout;
  }
  type = 'stream';
  level = 'error';
  stream = output;
  if (!options.json) {
    type = 'raw';
    stream = new CliStream(options.debug);
    stream.pipe(output);
  }
  if (!options.quiet) {
    level = options.debug ? 'trace' : 'info';
  }
  logger = bunyan.createLogger({
    name: 'nsync',
    src: options.debug,
    streams: [
      {
        level: level,
        type: type,
        stream: stream
      }
    ]
  });
  return logger;
};

main = function(argv) {
  var availableTransports, config, configPath, destination, error, exit, ignore, ignoreFile, key, logger, nsyncOpts, nversion, opt, options, out, smc, source, sourceDirectory, transport, transportConfig, transportDefaults, transportName, transportOptions, _ref1;
  nversion = process.version.substr(1).split('.').map(function(item) {
    return parseInt(item);
  });
  if (nversion[0] === 0 && nversion[1] < 10) {
    process.stderr.write("nsync requires node >=0.10 (you have: " + (nversion.join('.')) + ")\n");
    process.exit(1);
  }
  exit = function(code) {
    return setImmediate(function() {
      return process.exit(code);
    });
  };
  argv = minimist(argv.slice(2), {
    alias: {
      concurrency: 'C',
      config: 'c',
      destination: 'd',
      destructive: 'X',
      force: 'f',
      help: 'h',
      ignore: 'i',
      manifest: 'm',
      quiet: 'q',
      save: 'S',
      version: 'V'
    },
    boolean: ['debug', 'destructive', 'force', 'gitignore', 'help', 'pretend', 'quiet', 'version']
  });
  logger = createLogger(argv);
  if (argv.debug) {
    try {
      smc = require('source-map-support');
      smc.install();
    } catch (_error) {
      error = _error;
      logger.warn(error, 'npm install source-map-support to get correct line numbers');
    }
  }
  transportName = argv._[0];
  sourceDirectory = argv._[1];
  if ((transportName == null) || ((transportName == null) && argv.help)) {
    availableTransports = listModules(process.cwd()).filter(isTransport).map(normalizeTransportName).map(function(name) {
      return chalk.bold(name);
    }).join(' ');
    out = argv.help ? process.stdout : process.stderr;
    out.write("" + usage + "\n\navailable transports: " + (chalk.bold('fs')) + " " + availableTransports + "\n\n" + optionsUsage + "\n");
    exit(argv.help ? 0 : 1);
    return;
  }
  try {
    if (transportName === 'fs') {
      transport = nsync.FsTransport;
    } else {
      transport = require(resolveTransport(transportName));
    }
  } catch (_error) {
    error = _error;
    if (error.code === 'MODULE_NOT_FOUND') {
      logger.error("Transport " + transportName + " not found!");
    } else {
      logger.error(error, "Could not load transport '" + transportName + "'");
    }
    exit(1);
    return;
  }
  if ((sourceDirectory == null) || argv.help) {
    out = argv.help ? process.stdout : process.stderr;
    out.write("" + (usage.replace('<transport>', transportName)) + "\n\n" + (transportUsage(transport)) + "\n" + optionsUsage + "\n");
    exit(argv.help ? 0 : 1);
    return;
  }
  configPath = argv.config || './nsync.json';
  if (fs.existsSync(configPath)) {
    try {
      config = readJSONSync(configPath);
    } catch (_error) {
      error = _error;
      logger.error(error, "Failed loading config file: " + configPath);
      exit(1);
      return;
    }
  } else {
    config = {};
    if (argv.config != null) {
      logger.error("Could not find config file: " + configPath);
      exit(1);
      return;
    }
  }
  options = resolveOptions(argv, config, defaults);
  logger.debug({
    options: options
  }, 'resolved options');
  transportDefaults = {};
  _ref1 = transport.options;
  for (key in _ref1) {
    opt = _ref1[key];
    transportDefaults[key] = opt["default"] != null ? opt["default"] : null;
  }
  transportConfig = config[normalizeTransportName(transportName)] || {};
  transportOptions = resolveOptions(argv, transportConfig, transportDefaults);
  logger.debug({
    options: transportOptions
  }, 'transport options');
  for (key in transportOptions) {
    if ((transportOptions[key] == null) && transport.options[key].required) {
      logger.error("Transport " + transportName + " requires option '" + key + "' to be set");
      exit(1);
      return;
    }
  }
  ignore = Array.isArray(options.ignore) ? options.ignore : [options.ignore];
  if (options.gitignore) {
    ignore.push('.git');
    ignoreFile = path.join(sourceDirectory, '.gitignore');
    if (fs.existsSync(ignoreFile)) {
      fs.readFileSync(ignoreFile).toString().split('\n').filter(function(v) {
        return v.length;
      }).forEach(function(v) {
        return ignore.push(v);
      });
    }
  }
  source = new nsync.FsTransport({
    path: sourceDirectory
  });
  destination = new transport(transportOptions);
  nsyncOpts = {
    logger: logger,
    concurrency: options.concurrency,
    destructive: options.destructive,
    pretend: options.pretend,
    destinationPath: options.destination,
    manifest: options.manifest,
    forceRebuild: options.force,
    ignore: ignore
  };
  logger.info("Synchronizing %s using transport %s", sourceDirectory, transportName);
  return nsync(source, destination, nsyncOpts, function(error) {
    return exit(error != null ? 1 : 0);
  });
};

module.exports = main;

//# sourceMappingURL=index.map