var FsTransport, Transport, async, fs, path;

fs = require('fs');

async = require('async');

path = require('path');

Transport = (function() {

  /* Transport protocol, transports should implement methods described here. */
  function Transport(options) {

    /* Constructor, *options* are passed in from the cli tool or manually
        when using nsync as a library. Transports are responsible for validating
        their own options and should throw an error if something is amiss.
     */
  }

  Transport.prototype.setup = function(callback) {

    /* Do any needed setup here, callback when done. */
  };

  Transport.prototype.cleanup = function(callback) {

    /* Called after sync completes, do any cleanup needed here. close sockets etc. */
  };

  Transport.prototype.listDirectory = function(dirname, callback) {

    /* Callback with a array of filenames and directories in *dirname*.
        Directories should be indicated with a trailing slash (e.g. foo/).
     */
  };

  Transport.prototype.makeDirectory = function(dirname, callback) {

    /* Create *dirname*, *callback* when done. */
  };

  Transport.prototype.deleteDirectory = function(dirname, callback) {

    /* Delete directory *dirname*, callback when done.
        Only needs to handle empty directories.
     */
  };


  /* Fetching files: you can choose to implement either of the following methods.
      createReadStream is prefered and will be used first if implemented.
   */

  Transport.prototype.createReadStream = function(filename) {

    /* Return a readable stream for *filename*.
        File not found and other errors should be emitted on stream.
     */
  };

  Transport.prototype.getFile = function(filename, callback) {

    /* Callback with a *Stream* or *Buffer* object for *filename*,
        or an error if *filename* can not be found.
     */
  };

  Transport.prototype.putFile = function(filename, size, stream, callback) {

    /* Write *stream* of *size* bytes to *filename*, *callback* when done. */
  };

  Transport.prototype.deleteFile = function(filename, callback) {

    /* Delete *filename*, *callback* when done. */
  };

  return Transport;

})();

Transport.validate = function(transport, callback) {

  /* Validate *transport*, *callback* with error if it's missing any methods. */
  var method;
  if ((transport.createReadStream == null) && (transport.getFile == null)) {
    throw new Error("TransportError - " + transport.constructor.name + " missing file fetching, implement createReadStream or getFile");
  }
  for (method in Transport.prototype) {
    if (method === 'createReadStream' || method === 'getFile') {
      continue;
    }
    if (transport[method] == null) {
      throw new Error("TransportError - " + transport.constructor.name + " is missing method: " + method);
    }
  }
};

Transport.getName = function(transport) {

  /* Return canonical name for *transport*. */
  if (transport.name != null) {
    return transport.name;
  }
  return transport.constructor.name.toLowerCase().replace(/transport$/, '');
};

FsTransport = (function() {

  /* File system transport using node's fs module. */
  function FsTransport(options) {
    this.options = options;
    if (this.options.path == null) {
      throw new Error("Missing 'path' in options");
    }
  }

  FsTransport.prototype.setup = function(callback) {
    this.logger.debug('Verifying path %s', this.options.path);
    return async.waterfall([
      (function(_this) {
        return function(callback) {
          return fs.realpath(_this.options.path, callback);
        };
      })(this), (function(_this) {
        return function(localPath, callback) {
          _this.localPath = localPath;
          return fs.stat(_this.localPath, callback);
        };
      })(this), (function(_this) {
        return function(stat, callback) {
          if (!stat.isDirectory()) {
            return callback(new Error("Invalid path: " + _this.localPath));
          } else {
            return callback();
          }
        };
      })(this)
    ], (function(_this) {
      return function(error) {
        if ((error != null ? error.code : void 0) === 'ENOENT') {
          return callback(new Error("Invalid path: " + (_this.localPath || _this.options.path)));
        } else {
          return callback(error);
        }
      };
    })(this));
  };

  FsTransport.prototype.cleanup = function(callback) {
    return callback();
  };

  FsTransport.prototype.resolvePath = function(filename) {
    return path.join(this.localPath, filename);
  };

  FsTransport.prototype.createReadStream = function(filename) {
    return fs.createReadStream(this.resolvePath(filename));
  };

  FsTransport.prototype.putFile = function(filename, size, stream, callback) {
    var writeStream;
    writeStream = fs.createWriteStream(this.resolvePath(filename));
    writeStream.on('error', callback);
    writeStream.on('finish', callback);
    return stream.pipe(writeStream);
  };

  FsTransport.prototype.deleteFile = function(filename, callback) {
    return fs.unlink(this.resolvePath(filename), callback);
  };

  FsTransport.prototype.makeDirectory = function(filename, callback) {
    return fs.mkdir(this.resolvePath(filename), callback);
  };

  FsTransport.prototype.deleteDirectory = function(filename, callback) {
    return fs.rmdir(this.resolvePath(filename), callback);
  };

  FsTransport.prototype.listDirectory = function(dirname, callback) {
    var dir;
    dir = this.resolvePath(dirname);
    return async.waterfall([
      function(callback) {
        return fs.readdir(dir, callback);
      }, function(files, callback) {
        return async.map(files, function(file, callback) {
          return async.waterfall([
            function(callback) {
              return fs.stat(path.join(dir, file), callback);
            }, function(stat, callback) {
              if (stat.isDirectory()) {
                file += '/';
              }
              return callback(null, file);
            }
          ], callback);
        }, callback);
      }
    ], callback);
  };

  return FsTransport;

})();

FsTransport.options = {
  path: {
    required: true,
    description: 'filesystem path'
  }
};


/* Exports */

module.exports = {
  Transport: Transport,
  FsTransport: FsTransport
};

//# sourceMappingURL=transport.map