var Connection, SFTP, constants, fs, isDirectory, path;

Connection = require('ssh2');

constants = process.binding('constants');

isDirectory = function(attrs) {
  return (attrs.mode & constants.S_IFMT) === constants.S_IFDIR;
};

path = require('path');

fs = require('fs');

SFTP = (function() {
  function SFTP(options) {
    var key;
    this.host = options.host;
    this.port = options.port;
    this.username = options.username;
    key = '/Users/jnordberg/.ssh/id_rsa';
    this.privateKey = fs.readFileSync(key).toString();
  }

  SFTP.prototype.setup = function(callback) {
    this.connection = new Connection;
    this.connection.on('ready', (function(_this) {
      return function() {
        _this.open = true;
        _this.logger.verbose('ssh ready');
        return _this.connection.sftp(function(error, sftp) {
          _this.sftp = sftp;
          _this.logger.verbose('sftp open');
          _this.sftp.on('error', function(error) {
            _this.logger.error('sftp error!', error);
            return console.log('SFTP ERROR', error);
          });
          _this.sftp.on('end', _this.__onSftpEnd);
          return callback(error);
        });
      };
    })(this));
    this.__onConnectionEnd = (function(_this) {
      return function() {
        return _this.logger.error('ssh connection closed unexpectedly');
      };
    })(this);
    this.__onSftpEnd = (function(_this) {
      return function() {
        return _this.logger.error('sftp connection closed unexpectedly');
      };
    })(this);
    this.connection.on('end', this.__onConnectionEnd);
    this.connection.on('error', callback);
    return this.connection.connect({
      host: this.host,
      username: this.username,
      privateKey: this.privateKey
    });
  };

  SFTP.prototype.cleanup = function(callback) {
    this.open = false;
    this.sftp.removeListener('end', this.__onSftpEnd);
    this.connection.removeListener('end', this.__onConnectionEnd);
    this.sftp.end();
    return this.connection.end();
  };

  SFTP.prototype.listDirectory = function(dirname, callback) {
    return this.sftp.opendir(dirname, (function(_this) {
      return function(error, handle) {
        if (error != null) {
          return callback(error);
        }
        return _this.sftp.readdir(handle, function(error, list) {
          var file, rv, _i, _len;
          if (error == null) {
            rv = [];
            for (_i = 0, _len = list.length; _i < _len; _i++) {
              file = list[_i];
              if (file.filename === '.' || file.filename === '..') {
                continue;
              }
              if (isDirectory(file.attrs)) {
                rv.push(file.filename + '/');
              } else {
                rv.push(file.filename);
              }
            }
          }
          return callback(error, rv);
        });
      };
    })(this));
  };

  SFTP.prototype.makeDirectory = function(dirname, callback) {
    return this.sftp.mkdir(dirname, callback);
  };

  SFTP.prototype.deleteDirectory = function(dirname, callback) {
    return this.sftp.rmdir(dirname, callback);
  };

  SFTP.prototype.createReadStream = function(filename) {
    return this.sftp.createReadStream(filename);
  };

  SFTP.prototype.putFile = function(filename, size, stream, callback) {
    var writeStream;
    writeStream = this.sftp.createWriteStream(filename);
    writeStream.on('close', callback);
    return stream.pipe(writeStream);
  };

  SFTP.prototype.deleteFile = function(filename, callback) {
    return this.sftp.unlink(filename, callback);
  };

  return SFTP;

})();

SFTP.options = {
  host: {
    required: true,
    description: 'hostname'
  },
  username: {
    required: true,
    description: 'username'
  }
};

module.exports = SFTP;

//# sourceMappingURL=sftp.map