var Manifest, MemoryStream, async, crypto, getStream, hashStream, lsr, parseJSON, path, readStream, stringifyJSON, waterfall, _ref;

async = require('async');

crypto = require('crypto');

MemoryStream = require('memorystream');

path = require('path');

_ref = require('./utils'), waterfall = _ref.waterfall, getStream = _ref.getStream, lsr = _ref.lsr, stringifyJSON = _ref.stringifyJSON, parseJSON = _ref.parseJSON, readStream = _ref.readStream;

hashStream = function(stream, callback) {

  /* Calculates a sha1 checksum for *stream*. */
  var hash, size;
  hash = crypto.createHash('sha1');
  hash.setEncoding('hex');
  size = 0;
  stream.on('data', function(data) {
    return size += data.length;
  });
  stream.on('error', callback);
  stream.on('end', function() {
    hash.end();
    return callback(null, [size, hash.read()]);
  });
  stream.pipe(hash);
};

Manifest = (function() {
  function Manifest(files, lastUpdate) {
    this.files = files != null ? files : {};
    this.lastUpdate = lastUpdate;
    if (this.lastUpdate == null) {
      this.lastUpdate = Date.now();
    }
  }

  Manifest.prototype.toFile = function(filename, transport, callback) {

    /* Writes this manifest instance to a JSON file named *filename*
        using *transport*, calls *callback* when done or on error.
     */
    return waterfall([
      (function(_this) {
        return function(callback) {
          return stringifyJSON(_this.serialize(), callback);
        };
      })(this), function(json, callback) {
        var buffer, stream;
        buffer = new Buffer(json);
        stream = new MemoryStream;
        transport.putFile(filename, buffer.length, stream, callback);
        return setImmediate(function() {
          return stream.end(buffer);
        });
      }
    ], callback);
  };

  Manifest.prototype.serialize = function() {
    return {
      files: this.files,
      lastUpdate: this.lastUpdate
    };
  };

  Manifest.prototype.lookup = function(filename) {
    var file;
    file = this.files[filename];
    if (file != null) {
      return {
        file: filename,
        size: file[0],
        hash: file[1]
      };
    }
    return null;
  };

  return Manifest;

})();

Manifest.fromFile = function(filename, transport, callback) {

  /* Calls back with a Manifest instance created from a JSON file
      named *filename* using *transport*.
   */
  return waterfall([
    function(callback) {
      return getStream(transport, filename, callback);
    }, readStream, parseJSON, function(data, callback) {
      return callback(null, new Manifest(data.files, data.lastUpdate));
    }
  ], callback);
};

Manifest.fromDirectory = function(dirname, transport, concurrency, callback) {

  /* Calls back with a Manifest instance created
      from a *dirname* using *transport*.
   */
  return waterfall([
    function(callback) {
      return lsr(transport, dirname, concurrency, callback);
    }, function(result, callback) {
      var files;
      files = {};
      return async.forEachLimit(result, concurrency, function(file, callback) {
        var filename;
        filename = path.join(dirname, file);
        return waterfall([
          function(callback) {
            return getStream(transport, filename, callback);
          }, hashStream, function(hash, callback) {
            files[file] = hash;
            return callback();
          }
        ], callback);
      }, function(error) {
        var manifest;
        if (error == null) {
          manifest = new Manifest(files);
        }
        return callback(error, manifest);
      });
    }
  ], callback);
};

Manifest.diff = function(oldManifest, newManifest) {

  /* Return a array with differences between *oldManifest* and *newManifest*. */
  var diff, filename, newInfo, oldInfo, _ref1, _ref2;
  diff = [];
  _ref1 = newManifest.files;
  for (filename in _ref1) {
    newInfo = _ref1[filename];
    oldInfo = oldManifest.files[filename];
    if (oldInfo != null) {
      if (oldInfo[1] !== newInfo[1]) {
        diff.push({
          type: 'change',
          file: filename,
          hash: newInfo[1],
          oldHash: oldInfo[1],
          size: newInfo[0],
          oldSize: oldInfo[0]
        });
      }
    } else {
      diff.push({
        type: 'new',
        file: filename,
        hash: newInfo[1],
        oldHash: null,
        size: newInfo[0],
        oldSize: 0
      });
    }
  }
  _ref2 = oldManifest.files;
  for (filename in _ref2) {
    oldInfo = _ref2[filename];
    newInfo = newManifest.files[filename];
    if (newInfo == null) {
      diff.push({
        type: 'delete',
        file: filename,
        hash: null,
        oldHash: oldInfo[1],
        size: 0,
        oldSize: oldInfo[0]
      });
    }
  }
  return diff;
};

module.exports = {
  Manifest: Manifest
};

//# sourceMappingURL=manifest.map