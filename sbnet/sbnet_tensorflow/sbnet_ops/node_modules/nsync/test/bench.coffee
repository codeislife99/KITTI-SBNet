
NRUNS = 3

require 'shelljs/global'
async = require 'async'
nsync = require './../src/'
chalk = require 'chalk'
path = require 'path'

lpad = (str, length, padStr=' ') ->
  while chalk.stripColor(str).length < length
    str = padStr + str
  return str

rpad = (str, length, padStr=' ') ->
  while chalk.stripColor(str).length < length
    str = str + padStr
  return str

colorfn = (val, best, worst) ->
  if val is best
    return chalk.green
  else if val is worst
    return chalk.red
  else
    return chalk.bold

noop = ->
log = (val) -> process.stdout.write ''+val

shutupLogger =
  trace: noop
  debug: noop
  info: noop
  warn: log
  error: log
  fatal: log
  child: -> shutupLogger


sftp = require 'nsync-sftp'

bpath = path.resolve 'b'

source = new nsync.FsTransport {path: 'a'}
#destination = new nsync.FsTransport {path: '/'}
destination = new sftp {host: 'localhost', username: 'jnordberg', privateKey: '/Users/jnordberg/.ssh/id_rsa'}

opts = {logger: shutupLogger, destinationPath: bpath}

tests =

  lib1:
    desc: 'nsync lib (c=10)'
    before: (callback) ->
      exec 'rm -rf b && mkdir b'
      callback()
    run: (callback) ->
      opts.concurrency = 20
      nsync source, destination, opts, callback

  lib2:
    desc: 'nsync lib (c=4)'
    before: (callback) ->
      exec 'rm -rf b && mkdir b'
      callback()
    run: (callback) ->
      opts.concurrency = 4
      nsync source, destination, opts, callback

  # lib3:
  #   desc: 'nsync lib (c=16)'
  #   before: (callback) ->
  #     exec 'rm -rf b && mkdir b'
  #     callback()
  #   run: (callback) ->
  #     opts.concurrency = 16
  #     nsync source, destination, opts, callback

  # nsync1:
  #   desc: 'nsync -C 4'
  #   before: (callback) ->
  #     exec 'rm -rf b && mkdir b'
  #     callback()
  #   run: (callback) ->
  #     exec "nsync sftp -q -C 4 -d #{ bpath } --host localhost --private-key /Users/jnordberg/.ssh/id_rsa a", callback

  # nsync2:
  #   desc: 'nsync -C 10'
  #   before: (callback) ->
  #     exec 'rm -rf b && mkdir b'
  #     callback()
  #   run: (callback) ->
  #     exec "nsync sftp -q -C 10 -d #{ bpath } --host localhost --private-key /Users/jnordberg/.ssh/id_rsa a", callback



  rsync1:
    desc: 'rsync -r'
    before: (callback) ->
      exec 'rm -rf b && mkdir b'
      callback()
    run: (callback) ->
      exec 'rsync -r a localhost:'+bpath, callback

  rsync2:
    desc: 'rsync -r --checksum'
    before: (callback) ->
      exec 'rm -rf b && mkdir b'
      callback()
    run: (callback) ->
      exec 'rsync --checksum -r a localhost:'+bpath, callback

  # scp:
  #   desc: 'scp -r'
  #   before: (callback) ->
  #     exec 'rm -rf b && mkdir b'
  #     callback()
  #   run: (callback) ->
  #     exec 'scp -r a localhost:'+bpath, callback

flow = []
results = {}

log '\n'
for name, test of tests then do (name, test) ->
  results[name] = []
  for i in [0...NRUNS]
    flow.push (callback) ->
      log '.'
      test.before ->
        start = process.hrtime()
        test.run ->
          delta = process.hrtime start
          results[name].push delta[0] * 1000 + (delta[1] / 1e6)
          callback()

async.series flow, ->
  log '\n\n'
  log '  '
  log rpad 'test', 30
  log rpad 'average', 15
  log rpad 'median', 15
  log '\n\n'

  bestAvg = Infinity
  bestMed = Infinity
  worstAvg = 0
  worstMed = 0

  for name, result of results
    test = tests[name]
    avg = 0
    for val in result
      avg += val
    avg /= result.length
    test.avg = avg
    bestAvg = avg if avg < bestAvg
    worstAvg = avg if avg > worstAvg

    p = result.length / 2
    if result.length % 2
      med = result[Math.floor p]
    else
      med = (result[p-1] + result[p]) / 2
    test.med = med
    bestMed = med if med < bestMed
    worstMed = med if med > worstMed

  for name, test of tests
    log '  '
    log rpad(test.desc, 30)
    cfn = colorfn test.avg, bestAvg, worstAvg
    log rpad "#{ cfn(test.avg.toFixed(2)) } #{ chalk.gray('ms') }", 15
    cfn = colorfn test.med, bestMed, worstMed
    log rpad "#{ cfn(test.med.toFixed(2)) } #{ chalk.gray('ms') }", 15
    log '\n'
  log '\n\n'
